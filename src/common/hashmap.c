/*    ____         ________     __      _        ______  
 *   |  _ \_      |  ______|   |  \    | |     _/  ____\
 *   | | \_ \_    |  |         |   \   | |    /  _/   
 *   | |   \  |   |  |_____    | |\ \  | |   |  |   _____ 
 *   | |    | |   |  ______|   | | \ \ | |   |  |  |___  | 
 *   | |  _/ _|   |  |         | |  \ \| |    \  \    / /
 *   | |_/ _/     |  |_____    | |   \   |     \_ \__/ /
 *   |____/       |________|   |_|    \__|       \____/
 *               
 * __________________________________________________________
 * __________________________________________________________
 *                       Project DENG 
 *
 *
 * Copyright (C) 2020 - 2021
 * This Software is licensed under Apache License as described 
 * in the LICENSE.md file, which you should have recieved with 
 * this distribution.
 * 
 * You may reproduce and distribute copies of the
 * Work or Derivative Works thereof in any medium, with or without
 * modifications, and in Source or Object form, provided that You
 * meet the following conditions:
 *
 * (a) You must give any other recipients of the Work or
 *     Derivative Works a copy of this License; and
 *
 * (b) You must cause any modified files to carry prominent notices
 *     stating that You changed the files; and
 *
 * (c) You must retain, in the Source form of any Derivative Works
 *     that You distribute, all copyright, patent, trademark, and
 *     attribution notices from the Source form of the Work,
 *     excluding those notices that do not pertain to any part of
 *     the Derivative Works; and
 *
 * (d) If the Work includes a "NOTICE" text file as part of its
 *     distribution, then any Derivative Works that You distribute must
 *     include a readable copy of the attribution notices contained
 *     within such NOTICE file, excluding those notices that do not
 *     pertain to any part of the Derivative Works, in at least one
 *     of the following places: within a NOTICE text file distributed
 *     as part of the Derivative Works; within the Source form or
 *     documentation, if provided along with the Derivative Works; or,
 *     within a display generated by the Derivative Works, if and
 *     wherever such third-party notices normally appear. The contents
 *     of the NOTICE file are for informational purposes only and
 *     do not modify the License. You may add Your own attribution
 *     notices within Derivative Works that You distribute, alongside
 *     or as an addendum to the NOTICE text from the Work, provided
 *     that such additional attribution notices cannot be construed
 *     as modifying the License.
 *
 * You may add Your own copyright statement to Your modifications and
 * may provide additional or different license terms and conditions
 * for use, reproduction, or distribution of Your modifications, or
 * for any such Derivative Works as a whole, provided Your use,
 * reproduction, and distribution of the Work otherwise complies with
 * the conditions stated in this License.
 */ 


#define __HASHMAP_C
#include <common/hashmap.h>

#ifdef __cplusplus
extern "C" {
#endif
    static unsigned long crc32_table[] = {
        0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
        0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
        0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
        0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
        0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
        0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
        0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
        0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
        0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
        0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
        0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
        0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
        0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
        0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
        0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
        0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
        0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
        0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
        0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
        0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
        0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
        0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
        0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
        0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
        0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
        0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
        0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
        0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
        0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
        0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
        0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
        0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
        0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
        0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
        0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
        0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
        0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
        0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
        0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
        0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
        0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
        0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
        0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
        0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
        0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
        0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
        0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
        0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
        0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
        0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
        0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
        0x2d02ef8dL
    };

    /* 
     * Create a new hashmap 
     */
    void newHashmap (
        Hashmap *p_hashmap,
        size_t elem_c
    ) {
        p_hashmap->map_size = elem_c;
        p_hashmap->used_size = 0;
        p_hashmap->map_data = (__HashData*) calloc (
            p_hashmap->map_size,
            sizeof(__HashData)
        );

        p_hashmap->indices = (size_t*) calloc (
            p_hashmap->map_size,
            sizeof(size_t)
        );
    }


    /* 
     * Hashing function for hashmapping that returns index
     * This function is based on mostly Jenkins one at time hashing algorihm
     * Steps to finding index are following:
     * 1. Find crc32_key from key data
     * 2. Perform Jenkins one at time bitwise operations
     * 3. Perform three other Jenkins operations
     * 4. Multiply bit-shifted out_key with constant 0x9E3779B1
     * 5. Return hash % n
     */
    static size_t __hashfunc (
        void *key,
        size_t key_size,
        size_t map_c
    ) {
        size_t i;

        // Find 32 bit crs of the key
        size_t crc32_key = 0;
        for(i = 0; i < key_size; i++)
            crc32_key = crc32_table[(crc32_key ^ ((unsigned char*) key)[i]) & 0xff] ^ (crc32_key >> 8);

        // Jenkins one at time out_key
        size_t out_key = 0;
        for(i = 0;  i < key_size; i++) {
            out_key += (deng_ui32_t) crc32_key;
            out_key += out_key << 10;
            out_key ^= out_key >> 6;
        }
        out_key += out_key << 3;
        out_key ^= out_key >> 11;
        out_key += out_key << 15;

        out_key *= (out_key >> 5) * 0x9E3779B1;
        return out_key % map_c;
    }


    /* 
     * Reallocate more memory for buckets in hashmap 
     */
    static void __reallocateHashmap(Hashmap *p_hm) {
        size_t old_size = p_hm->map_size;
        p_hm->map_size *= 2;
        __HashData *tmp = (__HashData*) calloc ( 
            p_hm->map_size,
            sizeof(__HashData)
        );

        // Copy data from old map to a new one
        size_t i = 0, j = 0;
        for(i = 0; i < old_size; i++) {
            if(p_hm->map_data[i].key) {
                j = __hashfunc (
                    p_hm->map_data[i].key, 
                    p_hm->map_data[i].key_len,
                    p_hm->map_size
                );
                
                            
                if
                (
                    (tmp[j].data || 
                    tmp[j].key) && 
                    p_hm->map_data[i].key_len < tmp[j].key_len ? 
                    memcmp(p_hm->map_data[i].key, tmp[j].key, p_hm->map_data[i].key_len) :
                    memcmp(p_hm->map_data[i].key, tmp[j].key, tmp[j].key_len)
                ) {
                    deng_bool_t is_found = false;
                    deng_i64_t i = 0;
                    // Check for empty array spaces after collided key value 
                    for(i = (deng_i64_t) j; i < (deng_i64_t) p_hm->map_size; i++) {
                        if(!tmp[i].key && !tmp[i].data) {
                            is_found = true;
                            break;
                        }
                    }
                    
                    // Check for empty array spaces before collided key value
                    if(!is_found) {
                        for(i = (deng_i64_t) j; i >= 0; i--) {
                            if(!tmp[i].key && !tmp[i].data) {
                                is_found = true;
                                break;
                            }
                        }
                    }

                    tmp[i].key = p_hm->map_data[i].key;
                    tmp[i].key_len = p_hm->map_data[i].key_len;
                    tmp[i].data = p_hm->map_data[i].data;
                }
               
                else {
                    tmp[j].key = p_hm->map_data[i].key;
                    tmp[j].key_len = p_hm->map_data[i].key_len;
                    tmp[j].data = p_hm->map_data[i].data;
                }
            }
        }

        free(p_hm->map_data);
        p_hm->map_data = tmp;
    }


    /*
     * Key comparisson method
     * Returns 0 if keys are equal, 1 if key1 is longer than key2, -1 if 
     * key2 is longer than key1 then returns 2 if keys are the same length
     * but their memory areas do not match
     */
    static int __keycmp(void *key1, size_t n1, void *key2, size_t n2) {
        if(n1 < n2) return -1;
        else if(n1 > n2) return 1;
        else if(!memcmp(key1, key2, n1))
            return 0;
        else return 2;
    }

    
    /*
     * Search for the bucket index of the key element
     */
    static deng_i64_t __findIndex (
        Hashmap *p_hm, 
        void *key, 
        size_t key_size
    ) {
        deng_i64_t out = INT64_MAX;
        size_t index = __hashfunc (
            key,
            key_size,
            p_hm->map_size
        );

        if (!__keycmp(p_hm->map_data[index].key, p_hm->map_data[index].key_len, key, key_size))
            out = (deng_i64_t) index;
        
        else {
            // Perform linear search for the key
            deng_i64_t i = 0;
            deng_bool_t is_found = false;

            for(i = index; i < (deng_i64_t) p_hm->map_size; i++) {
                if
                (
                    p_hm->map_data[i].key && 
                    p_hm->map_data[i].key_len &&
                    !__keycmp(p_hm->map_data[i].key, p_hm->map_data[i].key_len, key, key_size)
                ) {
                    out = (deng_ui64_t) i;
                    is_found = true;
                    break;
                }
            }

            // If correct bucket was not found search from the front of the array
            if(!is_found) {
                for(i = index; i >= 0; i--) {
                    if
                    (
                        p_hm->map_data[i].key && 
                        p_hm->map_data[i].key_len &&
                        !__keycmp(p_hm->map_data[i].key, p_hm->map_data[i].key_len, key, key_size)
                    ) {
                        out = (deng_i64_t) i;
                        is_found = true;
                        break;
                    }
                }
            }
        }
        
        return out;
    }


    /* 
     * Push key and it's value to hashmap 
     */
    void pushToHashmap (
        Hashmap *p_hm,
        void *key,
        size_t key_size,
        void *data
    ) {
        if(p_hm->used_size >= p_hm->map_size)
           __reallocateHashmap(p_hm); 

        // Check if value with current key already exits
        size_t index = __hashfunc (
            key, 
            key_size, 
            p_hm->map_size
        );

        // Check if the bucket index is occupied with different data than the one being submitted
        if
        (
            (p_hm->map_data[index].data || 
            p_hm->map_data[index].key) && 
            __keycmp(p_hm->map_data[index].key, p_hm->map_data[index].key_len, key, key_size)
        ) {
            deng_bool_t is_found = false;
            deng_i64_t i = 0;
            // Check for empty array spaces after collided key value 
            for(i = (deng_i64_t) index; i < (deng_i64_t) p_hm->map_size; i++) {
                if(!p_hm->map_data[i].key && !p_hm->map_data[i].data) {
                    is_found = true;
                    break;
                }
            }
            
            // Check for empty array spaces before collided key value
            if(!is_found) {
                for(i = (deng_i64_t) index; i >= 0; i--) {
                    if(!p_hm->map_data[i].key && !p_hm->map_data[i].data) {
                        is_found = true;
                        break;
                    }
                }
            }

            p_hm->map_data[i].key = key;
            p_hm->map_data[i].key_len = key_size;
            p_hm->map_data[i].data = data;
            p_hm->indices[p_hm->used_size] = i; 
        }
       
        else {
            p_hm->map_data[index].data = data;
            p_hm->map_data[index].key_len = key_size;
            p_hm->map_data[index].key = key;
            p_hm->indices[p_hm->used_size] = index; 
        }

        p_hm->used_size++;
    }


    /*
     * Pop the value from hashmap that is specified with the key
     */
    void *popFromHashmap (
        Hashmap *p_hm,
        void *key,
        size_t key_size
    ) {
        deng_i64_t ind = __findIndex(p_hm, key, key_size);

        // Nothing to pop
        if(ind == INT64_MAX) return NULL;

        void *data = p_hm->map_data[ind].data;
        p_hm->map_data[ind].data = NULL;
        p_hm->map_data[ind].key = NULL;
        p_hm->map_data[ind].key_len = 0;

        // Find the bucket index in element indices array
        deng_bool_t shift = false;
        for(size_t i = 0; i < p_hm->used_size; i++) {
            if(!shift && p_hm->indices[i] == ind)
                shift = true;
            
            else if(shift) {
                p_hm->indices[i - 1] = p_hm->indices[i];
                if(i == p_hm->used_size - 1)
                    p_hm->indices[i] = 0;
            }
        }

        p_hm->used_size--;
        return data;
    }


    /*
     * Find the list of all elements' pointers in hashmap
     */
    void **getHashmapList(Hashmap *p_hm) {
        void **out = (void**) calloc (
            p_hm->used_size,
            sizeof(void*)
        );

        for(deng_ui64_t i = 0; i < p_hm->used_size; i++)
            out[i] = p_hm->map_data[p_hm->indices[i]].data;

        return out;
    }


    /* 
     * Find value with certain key 
     */
    void *findValue (
        Hashmap *p_hm,
        void *key,
        size_t key_len
    ) {
        deng_i64_t i = __findIndex(p_hm, key, key_len);
        if(i == INT64_MAX) return NULL;
        return p_hm->map_data[i].data;
    }


    /*
     * Destroy the given hashmap instance
     */
    void destroyHashmap(Hashmap *p_hm) {
        free(p_hm->map_data);
        free(p_hm->indices);
    }

#ifdef __cplusplus
}
#endif
